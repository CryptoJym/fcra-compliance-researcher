from __future__ import annotations

import argparse
import json
import shutil
import subprocess
import sys
from pathlib import Path
from typing import Any, Dict


def read_json(path: Path) -> Dict[str, Any]:
    try:
        return json.loads(path.read_text())
    except Exception:
        return {}


def write_json(path: Path, data: Dict[str, Any]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(json.dumps(data, indent=2, ensure_ascii=False) + "\n")


def is_empty_value(value: Any) -> bool:
    return value in (None, "", [], {})


def merge_without_overwrite(base: Any, patch: Any) -> Any:
    """Merge patch into base conservatively: fill only missing/empty fields; never overwrite non-empty values."""
    if isinstance(base, dict) and isinstance(patch, dict):
        out = dict(base)
        for k, v in patch.items():
            if k not in out:
                out[k] = v
            else:
                if isinstance(out[k], (dict, list)) and isinstance(v, type(out[k])):
                    out[k] = merge_without_overwrite(out[k], v)
                else:
                    if is_empty_value(out[k]) and not is_empty_value(v):
                        out[k] = v
        return out
    if isinstance(base, list) and isinstance(patch, list):
        # Append any items from patch not already present
        out_list = list(base)
        for item in patch:
            if item not in out_list:
                out_list.append(item)
        return out_list
    # Different types or scalars: keep base unless it's empty
    return patch if is_empty_value(base) else base


def simple_validate(doc: Dict[str, Any]) -> bool:
    # Minimal checks; real validation is handled elsewhere
    if not isinstance(doc, dict):
        return False
    if "jurisdiction" not in doc and "jurisdiction_path" not in doc:
        return False
    return True


def regenerate_docs(project_root: Path) -> None:
    # Minimal docs regeneration
    status = project_root / "PROJECT_STATUS.md"
    gaps = project_root / "RESEARCH_GAPS_REPORT.md"
    status.write_text("# Project Status\n\nUpdated by apply_research_patch.\n")
    gaps.write_text("# Research Gaps Report\n\nAutogenerated summary.\n")


def main() -> int:
    parser = argparse.ArgumentParser(description="Safely apply research patch to a jurisdiction file")
    parser.add_argument("--file", required=True, help="Path to jurisdiction JSON file")
    parser.add_argument("--input", required=True, help="Path to patch JSON file")
    parser.add_argument("--generate-docs", action="store_true", help="Regenerate docs after success")
    args = parser.parse_args()

    file_path = Path(args.file)
    patch_path = Path(args.input)

    if not patch_path.exists():
        print(f"Patch not found: {patch_path}", file=sys.stderr)
        return 2

    original = read_json(file_path) if file_path.exists() else {}
    patch = read_json(patch_path)

    backup_path = file_path.with_suffix(file_path.suffix + ".bak")
    if file_path.exists():
        shutil.copyfile(file_path, backup_path)

    merged = merge_without_overwrite(original, patch)
    write_json(file_path, merged)

    # Run a lightweight validation; rollback on failure
    if not simple_validate(merged):
        if backup_path.exists():
            shutil.copyfile(backup_path, file_path)
        print("Validation failed; rolled back.", file=sys.stderr)
        return 1

    # Optional docs regeneration
    if args.generate_docs:
        regenerate_docs(Path(__file__).resolve().parents[1])

    return 0


if __name__ == "__main__":
    sys.exit(main())


